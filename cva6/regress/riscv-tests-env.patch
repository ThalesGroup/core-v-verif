diff --git a/p/riscv_test.h b/p/riscv_test.h
index 88ca6c1..3bd4767 100644
--- a/p/riscv_test.h
+++ b/p/riscv_test.h
@@ -110,7 +110,7 @@
 #define INIT_SATP                                                      \
   la t0, 1f;                                                            \
   csrw mtvec, t0;                                                       \
-  csrwi sptbr, 0;                                                       \
+  csrwi satp, 0;                                                        \
   .align 2;                                                             \
 1:
 
diff --git a/v/entry.S b/v/entry.S
index fa492e6..49b2d3e 100644
--- a/v/entry.S
+++ b/v/entry.S
@@ -153,7 +153,7 @@ trap_entry:
   STORE  t0,32*REGBYTES(sp)
   csrr   t0,sepc
   STORE  t0,33*REGBYTES(sp)
-  csrr   t0,sbadaddr
+  csrr   t0,stval
   STORE  t0,34*REGBYTES(sp)
   csrr   t0,scause
   STORE  t0,35*REGBYTES(sp)
diff --git a/v/vm.c b/v/vm.c
index 6bf05f7..bb02e55 100644
--- a/v/vm.c
+++ b/v/vm.c
@@ -17,8 +17,8 @@
 void trap_entry();
 void pop_tf(trapframe_t*);
 
-volatile uint64_t tohost;
-volatile uint64_t fromhost;
+extern volatile uint64_t tohost;
+extern volatile uint64_t fromhost;
 
 static void do_tohost(uint64_t tohost_value)
 {
@@ -172,7 +172,11 @@ void handle_fault(uintptr_t addr, uintptr_t cause)
   user_llpt[addr/PGSIZE] = new_pte;
   flush_page(addr);
 
+/* In GCC this builtin is silently ignored. In LLVM it gets remapped
+   to library call __clear_cache which is NOT implemented.  */
+#ifndef __llvm__
   __builtin___clear_cache(0,0);
+#endif
 }
 
 void handle_trap(trapframe_t* tf)
@@ -253,10 +257,10 @@ void vm_boot(uintptr_t test_addr)
 # error
 #endif
   uintptr_t vm_choice = SATP_MODE_CHOICE;
-  uintptr_t sptbr_value = ((uintptr_t)l1pt >> PGSHIFT)
-                        | (vm_choice * (SATP_MODE & ~(SATP_MODE<<1)));
-  write_csr(sptbr, sptbr_value);
-  if (read_csr(sptbr) != sptbr_value)
+  uintptr_t satp_value = ((uintptr_t)l1pt >> PGSHIFT)
+                          | (vm_choice * (SATP_MODE & ~(SATP_MODE<<1)));
+  write_csr(satp, satp_value);
+  if (read_csr(satp) != satp_value)
     assert(!"unsupported satp mode");
 
   // Set up PMPs if present, ignoring illegal instruction trap if not.
